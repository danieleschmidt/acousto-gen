"""
Security Manager for Acoustic Holography Systems.
Implements authentication, authorization, input validation, and security monitoring.
"""

import hashlib\nimport hmac\nimport secrets\nimport logging\nimport time\nimport re\nfrom typing import Dict, List, Optional, Any, Tuple, Set\nfrom dataclasses import dataclass, field\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nimport json\n\n# Optional JWT support\ntry:\n    import jwt\n    HAS_JWT = True\nexcept ImportError:\n    HAS_JWT = False\n\nlogger = logging.getLogger(__name__)\n\n\nclass SecurityLevel(Enum):\n    \"\"\"Security clearance levels.\"\"\"\n    PUBLIC = \"public\"\n    USER = \"user\"\n    OPERATOR = \"operator\"\n    ADMIN = \"admin\"\n    SYSTEM = \"system\"\n\n\nclass SecurityEvent(Enum):\n    \"\"\"Security event types.\"\"\"\n    LOGIN_SUCCESS = \"login_success\"\n    LOGIN_FAILURE = \"login_failure\"\n    UNAUTHORIZED_ACCESS = \"unauthorized_access\"\n    PRIVILEGE_ESCALATION = \"privilege_escalation\"\n    SUSPICIOUS_ACTIVITY = \"suspicious_activity\"\n    API_RATE_LIMIT = \"api_rate_limit\"\n    INPUT_VALIDATION_FAILURE = \"input_validation_failure\"\n    SECURITY_POLICY_VIOLATION = \"security_policy_violation\"\n\n\n@dataclass\nclass SecurityLog:\n    \"\"\"Security event log entry.\"\"\"\n    event_type: SecurityEvent\n    user_id: Optional[str]\n    ip_address: Optional[str]\n    user_agent: Optional[str]\n    details: Dict[str, Any]\n    timestamp: datetime = field(default_factory=datetime.now)\n    severity: str = \"info\"\n\n\n@dataclass\nclass UserSession:\n    \"\"\"User session information.\"\"\"\n    user_id: str\n    session_id: str\n    security_level: SecurityLevel\n    ip_address: str\n    user_agent: str\n    created_at: datetime = field(default_factory=datetime.now)\n    last_activity: datetime = field(default_factory=datetime.now)\n    permissions: Set[str] = field(default_factory=set)\n    expires_at: Optional[datetime] = None\n\n\nclass InputValidator:\n    \"\"\"Comprehensive input validation and sanitization.\"\"\"\n    \n    # Regex patterns for validation\n    PATTERNS = {\n        'email': re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'),\n        'username': re.compile(r'^[a-zA-Z0-9_]{3,32}$'),\n        'hardware_id': re.compile(r'^[a-zA-Z0-9_-]{1,64}$'),\n        'experiment_name': re.compile(r'^[a-zA-Z0-9_\\s\\-\\.]{1,128}$'),\n        'filename': re.compile(r'^[a-zA-Z0-9_\\-\\.]{1,255}$'),\n        'uuid': re.compile(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'),\n        'ip_address': re.compile(r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'),\n    }\n    \n    # Dangerous patterns to reject\n    DANGEROUS_PATTERNS = [\n        re.compile(r'<script.*?>.*?</script>', re.IGNORECASE | re.DOTALL),  # XSS\n        re.compile(r'javascript:', re.IGNORECASE),  # JavaScript injection\n        re.compile(r'on\\w+\\s*=', re.IGNORECASE),  # Event handlers\n        re.compile(r'\\b(union|select|insert|delete|drop|alter|create|exec|execute)\\b', re.IGNORECASE),  # SQL injection\n        re.compile(r'\\.\\./|\\.\\.\\\\'),  # Path traversal\n        re.compile(r'[<>&\"\\']'),  # HTML/XML characters\n    ]\n    \n    @classmethod\n    def validate_string(cls, value: str, pattern_name: str, max_length: int = None) -> Tuple[bool, str]:\n        \"\"\"\n        Validate string against pattern and security checks.\n        \n        Args:\n            value: String to validate\n            pattern_name: Pattern name from PATTERNS dict\n            max_length: Maximum allowed length\n            \n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        if not isinstance(value, str):\n            return False, \"Value must be a string\"\n        \n        # Check length\n        if max_length and len(value) > max_length:\n            return False, f\"Value too long (max {max_length} characters)\"\n        \n        # Check for dangerous patterns\n        for pattern in cls.DANGEROUS_PATTERNS:\n            if pattern.search(value):\n                return False, \"Value contains potentially dangerous content\"\n        \n        # Check against specific pattern\n        if pattern_name in cls.PATTERNS:\n            if not cls.PATTERNS[pattern_name].match(value):\n                return False, f\"Value does not match required pattern for {pattern_name}\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def validate_number(cls, value: Any, min_val: float = None, max_val: float = None) -> Tuple[bool, str]:\n        \"\"\"\n        Validate numeric value.\n        \n        Args:\n            value: Value to validate\n            min_val: Minimum allowed value\n            max_val: Maximum allowed value\n            \n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        try:\n            num_value = float(value)\n        except (TypeError, ValueError):\n            return False, \"Value must be a number\"\n        \n        if min_val is not None and num_value < min_val:\n            return False, f\"Value must be >= {min_val}\"\n        \n        if max_val is not None and num_value > max_val:\n            return False, f\"Value must be <= {max_val}\"\n        \n        # Check for NaN or infinity\n        if not (num_value == num_value):  # NaN check\n            return False, \"Value cannot be NaN\"\n        \n        if abs(num_value) == float('inf'):\n            return False, \"Value cannot be infinite\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def validate_array(cls, value: Any, element_validator: callable, max_length: int = None) -> Tuple[bool, str]:\n        \"\"\"\n        Validate array and its elements.\n        \n        Args:\n            value: Array to validate\n            element_validator: Function to validate each element\n            max_length: Maximum allowed array length\n            \n        Returns:\n            Tuple of (is_valid, error_message)\n        \"\"\"\n        if not isinstance(value, (list, tuple)):\n            return False, \"Value must be a list or tuple\"\n        \n        if max_length and len(value) > max_length:\n            return False, f\"Array too long (max {max_length} elements)\"\n        \n        for i, element in enumerate(value):\n            is_valid, error = element_validator(element)\n            if not is_valid:\n                return False, f\"Element {i}: {error}\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def validate_position(cls, position: Any) -> Tuple[bool, str]:\n        \"\"\"Validate 3D position array.\"\"\"\n        def validate_coord(coord):\n            return cls.validate_number(coord, -10.0, 10.0)  # ±10m workspace limit\n        \n        is_valid, error = cls.validate_array(position, validate_coord, 3)\n        if not is_valid:\n            return False, f\"Position validation failed: {error}\"\n        \n        if len(position) != 3:\n            return False, \"Position must have exactly 3 coordinates\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def validate_phases(cls, phases: Any) -> Tuple[bool, str]:\n        \"\"\"Validate phase array.\"\"\"\n        def validate_phase(phase):\n            return cls.validate_number(phase, 0.0, 6.283185307179586)  # 0 to 2π\n        \n        is_valid, error = cls.validate_array(phases, validate_phase, 1024)  # Max 1024 elements\n        if not is_valid:\n            return False, f\"Phase validation failed: {error}\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def validate_amplitudes(cls, amplitudes: Any) -> Tuple[bool, str]:\n        \"\"\"Validate amplitude array.\"\"\"\n        def validate_amplitude(amplitude):\n            return cls.validate_number(amplitude, 0.0, 1.0)  # 0 to 1\n        \n        is_valid, error = cls.validate_array(amplitudes, validate_amplitude, 1024)\n        if not is_valid:\n            return False, f\"Amplitude validation failed: {error}\"\n        \n        return True, \"\"\n    \n    @classmethod\n    def sanitize_string(cls, value: str, max_length: int = None) -> str:\n        \"\"\"Sanitize string by removing dangerous content.\"\"\"\n        if not isinstance(value, str):\n            return str(value)\n        \n        # Remove dangerous patterns\n        sanitized = value\n        for pattern in cls.DANGEROUS_PATTERNS:\n            sanitized = pattern.sub('', sanitized)\n        \n        # Trim whitespace\n        sanitized = sanitized.strip()\n        \n        # Truncate if needed\n        if max_length:\n            sanitized = sanitized[:max_length]\n        \n        return sanitized\n\n\nclass RateLimiter:\n    \"\"\"Rate limiting for API endpoints.\"\"\"\n    \n    def __init__(self):\n        self.requests: Dict[str, List[float]] = {}\n        self.limits = {\n            'default': (100, 3600),      # 100 requests per hour\n            'login': (5, 300),           # 5 login attempts per 5 minutes\n            'admin': (1000, 3600),       # 1000 requests per hour for admins\n            'hardware': (10, 60),        # 10 hardware commands per minute\n            'field_calc': (50, 300),     # 50 field calculations per 5 minutes\n        }\n    \n    def is_allowed(self, identifier: str, category: str = 'default') -> bool:\n        \"\"\"\n        Check if request is allowed based on rate limits.\n        \n        Args:\n            identifier: Unique identifier (IP address, user ID, etc.)\n            category: Rate limit category\n            \n        Returns:\n            True if request is allowed, False otherwise\n        \"\"\"\n        now = time.time()\n        key = f\"{identifier}:{category}\"\n        \n        if key not in self.requests:\n            self.requests[key] = []\n        \n        # Clean old requests\n        limit_count, time_window = self.limits.get(category, self.limits['default'])\n        cutoff_time = now - time_window\n        self.requests[key] = [req_time for req_time in self.requests[key] if req_time > cutoff_time]\n        \n        # Check limit\n        if len(self.requests[key]) >= limit_count:\n            return False\n        \n        # Record this request\n        self.requests[key].append(now)\n        return True\n    \n    def get_remaining(self, identifier: str, category: str = 'default') -> int:\n        \"\"\"Get remaining requests for identifier.\"\"\"\n        now = time.time()\n        key = f\"{identifier}:{category}\"\n        \n        if key not in self.requests:\n            limit_count, _ = self.limits.get(category, self.limits['default'])\n            return limit_count\n        \n        limit_count, time_window = self.limits.get(category, self.limits['default'])\n        cutoff_time = now - time_window\n        recent_requests = [req_time for req_time in self.requests[key] if req_time > cutoff_time]\n        \n        return max(0, limit_count - len(recent_requests))\n\n\nclass SecurityManager:\n    \"\"\"\n    Comprehensive security management for acoustic holography systems.\n    Handles authentication, authorization, input validation, and security monitoring.\n    \"\"\"\n    \n    def __init__(self, secret_key: Optional[str] = None):\n        \"\"\"Initialize security manager.\"\"\"\n        self.secret_key = secret_key or secrets.token_urlsafe(32)\n        self.sessions: Dict[str, UserSession] = {}\n        self.security_logs: List[SecurityLog] = []\n        self.rate_limiter = RateLimiter()\n        self.validator = InputValidator()\n        \n        # Security policies\n        self.session_timeout = timedelta(hours=8)  # 8 hour session timeout\n        self.max_login_attempts = 5\n        self.lockout_duration = timedelta(minutes=15)\n        self.require_secure_communication = True\n        \n        # Failed login tracking\n        self.failed_logins: Dict[str, List[datetime]] = {}\n        \n        # Permissions mapping\n        self.permissions = {\n            SecurityLevel.PUBLIC: set(),\n            SecurityLevel.USER: {\n                'view_experiments',\n                'create_experiments',\n                'view_hardware_status'\n            },\n            SecurityLevel.OPERATOR: {\n                'view_experiments',\n                'create_experiments',\n                'edit_experiments',\n                'control_hardware',\n                'view_hardware_status',\n                'view_system_status'\n            },\n            SecurityLevel.ADMIN: {\n                'view_experiments',\n                'create_experiments',\n                'edit_experiments',\n                'delete_experiments',\n                'control_hardware',\n                'configure_hardware',\n                'view_hardware_status',\n                'view_system_status',\n                'manage_users',\n                'view_security_logs'\n            },\n            SecurityLevel.SYSTEM: set()  # All permissions\n        }\n        \n        logger.info(\"Security Manager initialized\")\n    \n    def hash_password(self, password: str, salt: Optional[bytes] = None) -> Tuple[str, bytes]:\n        \"\"\"\n        Hash password with salt.\n        \n        Args:\n            password: Plain text password\n            salt: Optional salt (generated if not provided)\n            \n        Returns:\n            Tuple of (hashed_password, salt)\n        \"\"\"\n        if salt is None:\n            salt = secrets.token_bytes(32)\n        \n        hashed = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n        return hashed.hex(), salt\n    \n    def verify_password(self, password: str, hashed_password: str, salt: bytes) -> bool:\n        \"\"\"Verify password against hash.\"\"\"\n        computed_hash, _ = self.hash_password(password, salt)\n        return hmac.compare_digest(computed_hash, hashed_password)\n    \n    def generate_session_id(self) -> str:\n        \"\"\"Generate cryptographically secure session ID.\"\"\"\n        return secrets.token_urlsafe(32)\n    \n    def create_session(self, user_id: str, security_level: SecurityLevel, \n                      ip_address: str, user_agent: str) -> str:\n        \"\"\"\n        Create new user session.\n        \n        Args:\n            user_id: User identifier\n            security_level: User's security clearance\n            ip_address: User's IP address\n            user_agent: User's browser/client info\n            \n        Returns:\n            Session ID\n        \"\"\"\n        session_id = self.generate_session_id()\n        \n        # Set session expiration\n        expires_at = datetime.now() + self.session_timeout\n        \n        # Get permissions for security level\n        permissions = self.permissions.get(security_level, set())\n        \n        session = UserSession(\n            user_id=user_id,\n            session_id=session_id,\n            security_level=security_level,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            expires_at=expires_at,\n            permissions=permissions.copy()\n        )\n        \n        self.sessions[session_id] = session\n        \n        # Log successful login\n        self.log_security_event(\n            SecurityEvent.LOGIN_SUCCESS,\n            user_id,\n            ip_address,\n            user_agent,\n            {\"security_level\": security_level.value}\n        )\n        \n        logger.info(f\"Created session for user {user_id} with level {security_level.value}\")\n        return session_id\n    \n    def validate_session(self, session_id: str, ip_address: str = None) -> Optional[UserSession]:\n        \"\"\"\n        Validate and return session if valid.\n        \n        Args:\n            session_id: Session ID to validate\n            ip_address: Optional IP address to check\n            \n        Returns:\n            UserSession if valid, None otherwise\n        \"\"\"\n        if session_id not in self.sessions:\n            return None\n        \n        session = self.sessions[session_id]\n        now = datetime.now()\n        \n        # Check if session has expired\n        if session.expires_at and now > session.expires_at:\n            self.invalidate_session(session_id)\n            return None\n        \n        # Check IP address if provided (optional security measure)\n        if ip_address and session.ip_address != ip_address:\n            self.log_security_event(\n                SecurityEvent.SUSPICIOUS_ACTIVITY,\n                session.user_id,\n                ip_address,\n                None,\n                {\n                    \"reason\": \"IP address mismatch\",\n                    \"session_ip\": session.ip_address,\n                    \"request_ip\": ip_address\n                },\n                \"warning\"\n            )\n            # Could invalidate session here for strict security\n        \n        # Update last activity\n        session.last_activity = now\n        \n        return session\n    \n    def invalidate_session(self, session_id: str):\n        \"\"\"Invalidate user session.\"\"\"\n        if session_id in self.sessions:\n            session = self.sessions[session_id]\n            del self.sessions[session_id]\n            logger.info(f\"Invalidated session for user {session.user_id}\")\n    \n    def has_permission(self, session_id: str, permission: str) -> bool:\n        \"\"\"\n        Check if session has specific permission.\n        \n        Args:\n            session_id: Session ID\n            permission: Permission to check\n            \n        Returns:\n            True if permission granted, False otherwise\n        \"\"\"\n        session = self.validate_session(session_id)\n        if not session:\n            return False\n        \n        # SYSTEM level has all permissions\n        if session.security_level == SecurityLevel.SYSTEM:\n            return True\n        \n        return permission in session.permissions\n    \n    def require_permission(self, session_id: str, permission: str) -> bool:\n        \"\"\"\n        Check permission and log unauthorized access attempts.\n        \n        Args:\n            session_id: Session ID\n            permission: Required permission\n            \n        Returns:\n            True if authorized, False otherwise\n        \"\"\"\n        session = self.validate_session(session_id)\n        if not session:\n            self.log_security_event(\n                SecurityEvent.UNAUTHORIZED_ACCESS,\n                None,\n                None,\n                None,\n                {\"reason\": \"Invalid session\", \"permission\": permission},\n                \"warning\"\n            )\n            return False\n        \n        if not self.has_permission(session_id, permission):\n            self.log_security_event(\n                SecurityEvent.UNAUTHORIZED_ACCESS,\n                session.user_id,\n                session.ip_address,\n                session.user_agent,\n                {\n                    \"reason\": \"Insufficient permissions\",\n                    \"permission\": permission,\n                    \"user_level\": session.security_level.value\n                },\n                \"warning\"\n            )\n            return False\n        \n        return True\n    \n    def check_rate_limit(self, identifier: str, category: str = 'default') -> bool:\n        \"\"\"Check rate limit for identifier.\"\"\"\n        allowed = self.rate_limiter.is_allowed(identifier, category)\n        \n        if not allowed:\n            self.log_security_event(\n                SecurityEvent.API_RATE_LIMIT,\n                None,\n                identifier,\n                None,\n                {\"category\": category},\n                \"info\"\n            )\n        \n        return allowed\n    \n    def validate_input(self, input_data: Dict[str, Any], validation_rules: Dict[str, Any]) -> Tuple[bool, List[str]]:\n        \"\"\"\n        Validate input data against rules.\n        \n        Args:\n            input_data: Data to validate\n            validation_rules: Validation rules per field\n            \n        Returns:\n            Tuple of (is_valid, error_list)\n        \"\"\"\n        errors = []\n        \n        for field, rules in validation_rules.items():\n            if field not in input_data:\n                if rules.get('required', False):\n                    errors.append(f\"Field '{field}' is required\")\n                continue\n            \n            value = input_data[field]\n            \n            # Type validation\n            if 'type' in rules:\n                expected_type = rules['type']\n                if expected_type == 'string' and not isinstance(value, str):\n                    errors.append(f\"Field '{field}' must be a string\")\n                    continue\n                elif expected_type == 'number' and not isinstance(value, (int, float)):\n                    errors.append(f\"Field '{field}' must be a number\")\n                    continue\n                elif expected_type == 'array' and not isinstance(value, (list, tuple)):\n                    errors.append(f\"Field '{field}' must be an array\")\n                    continue\n            \n            # String validation\n            if isinstance(value, str):\n                if 'pattern' in rules:\n                    is_valid, error = self.validator.validate_string(\n                        value, rules['pattern'], rules.get('max_length')\n                    )\n                    if not is_valid:\n                        errors.append(f\"Field '{field}': {error}\")\n                elif 'max_length' in rules and len(value) > rules['max_length']:\n                    errors.append(f\"Field '{field}' too long (max {rules['max_length']})\") \n            \n            # Number validation\n            if isinstance(value, (int, float)):\n                is_valid, error = self.validator.validate_number(\n                    value, rules.get('min'), rules.get('max')\n                )\n                if not is_valid:\n                    errors.append(f\"Field '{field}': {error}\")\n            \n            # Custom validation\n            if 'custom_validator' in rules:\n                is_valid, error = rules['custom_validator'](value)\n                if not is_valid:\n                    errors.append(f\"Field '{field}': {error}\")\n        \n        # Log validation failures\n        if errors:\n            self.log_security_event(\n                SecurityEvent.INPUT_VALIDATION_FAILURE,\n                None,\n                None,\n                None,\n                {\"errors\": errors, \"field_count\": len(errors)},\n                \"info\"\n            )\n        \n        return len(errors) == 0, errors\n    \n    def log_security_event(self, event_type: SecurityEvent, user_id: Optional[str],\n                          ip_address: Optional[str], user_agent: Optional[str],\n                          details: Dict[str, Any], severity: str = \"info\"):\n        \"\"\"Log security event.\"\"\"\n        log_entry = SecurityLog(\n            event_type=event_type,\n            user_id=user_id,\n            ip_address=ip_address,\n            user_agent=user_agent,\n            details=details,\n            severity=severity\n        )\n        \n        self.security_logs.append(log_entry)\n        \n        # Log to system logger\n        log_message = f\"Security Event [{event_type.value}]: {json.dumps(details)}\"\n        if severity == \"warning\":\n            logger.warning(log_message)\n        elif severity == \"error\":\n            logger.error(log_message)\n        else:\n            logger.info(log_message)\n        \n        # Keep only recent logs (last 1000)\n        if len(self.security_logs) > 1000:\n            self.security_logs = self.security_logs[-1000:]\n    \n    def get_security_status(self) -> Dict[str, Any]:\n        \"\"\"Get security system status.\"\"\"\n        now = datetime.now()\n        cutoff_time = now - timedelta(hours=24)\n        \n        recent_logs = [log for log in self.security_logs if log.timestamp > cutoff_time]\n        \n        # Count events by type\n        event_counts = {}\n        for log in recent_logs:\n            event_type = log.event_type.value\n            event_counts[event_type] = event_counts.get(event_type, 0) + 1\n        \n        return {\n            \"active_sessions\": len(self.sessions),\n            \"total_security_logs\": len(self.security_logs),\n            \"recent_logs_24h\": len(recent_logs),\n            \"event_counts_24h\": event_counts,\n            \"session_timeout_hours\": self.session_timeout.total_seconds() / 3600,\n            \"require_secure_communication\": self.require_secure_communication\n        }\n    \n    def get_security_logs(self, hours: int = 24, event_type: SecurityEvent = None) -> List[Dict[str, Any]]:\n        \"\"\"Get security logs for specified time period.\"\"\"\n        cutoff_time = datetime.now() - timedelta(hours=hours)\n        \n        filtered_logs = [log for log in self.security_logs if log.timestamp > cutoff_time]\n        \n        if event_type:\n            filtered_logs = [log for log in filtered_logs if log.event_type == event_type]\n        \n        return [\n            {\n                \"timestamp\": log.timestamp.isoformat(),\n                \"event_type\": log.event_type.value,\n                \"user_id\": log.user_id,\n                \"ip_address\": log.ip_address,\n                \"user_agent\": log.user_agent,\n                \"details\": log.details,\n                \"severity\": log.severity\n            }\n            for log in filtered_logs\n        ]\n    \n    def create_jwt_token(self, user_id: str, security_level: SecurityLevel, \n                        expires_in: int = 3600) -> Optional[str]:\n        \"\"\"\n        Create JWT token for API authentication.\n        \n        Args:\n            user_id: User identifier\n            security_level: User's security level\n            expires_in: Token expiration in seconds\n            \n        Returns:\n            JWT token string or None if JWT not available\n        \"\"\"\n        if not HAS_JWT:\n            logger.warning(\"JWT library not available for token creation\")\n            return None\n        \n        payload = {\n            'user_id': user_id,\n            'security_level': security_level.value,\n            'exp': datetime.utcnow() + timedelta(seconds=expires_in),\n            'iat': datetime.utcnow(),\n            'iss': 'acousto-gen'\n        }\n        \n        try:\n            token = jwt.encode(payload, self.secret_key, algorithm='HS256')\n            return token\n        except Exception as e:\n            logger.error(f\"Failed to create JWT token: {e}\")\n            return None\n    \n    def verify_jwt_token(self, token: str) -> Optional[Dict[str, Any]]:\n        \"\"\"\n        Verify and decode JWT token.\n        \n        Args:\n            token: JWT token to verify\n            \n        Returns:\n            Decoded payload or None if invalid\n        \"\"\"\n        if not HAS_JWT:\n            return None\n        \n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=['HS256'])\n            return payload\n        except jwt.ExpiredSignatureError:\n            logger.warning(\"JWT token has expired\")\n            return None\n        except jwt.InvalidTokenError as e:\n            logger.warning(f\"Invalid JWT token: {e}\")\n            return None\n\n\n# Global security manager instance\n_security_manager: Optional[SecurityManager] = None\n\n\ndef get_security_manager() -> SecurityManager:\n    \"\"\"Get global security manager instance.\"\"\"\n    global _security_manager\n    if _security_manager is None:\n        _security_manager = SecurityManager()\n    return _security_manager\n\n\ndef initialize_security(secret_key: Optional[str] = None):\n    \"\"\"Initialize global security manager.\"\"\"\n    global _security_manager\n    _security_manager = SecurityManager(secret_key)\n    logger.info(\"Global security manager initialized\")\n"