"""
System Monitoring and Telemetry for Acoustic Holography Systems.
Provides comprehensive monitoring, metrics collection, and observability.
"""

import logging
import time
import threading
import psutil
import json
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from collections import deque, defaultdict
import statistics

# Optional dependencies for metrics
try:
    from prometheus_client import Counter, Histogram, Gauge, CollectorRegistry, generate_latest
    HAS_PROMETHEUS = True\nexcept ImportError:\n    HAS_PROMETHEUS = False\n\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass SystemMetric:\n    \"\"\"Individual system metric measurement.\"\"\"\n    name: str\n    value: float\n    unit: str\n    timestamp: datetime = field(default_factory=datetime.now)\n    tags: Dict[str, str] = field(default_factory=dict)\n    help: str = \"\"\n\n\n@dataclass\nclass PerformanceStats:\n    \"\"\"Performance statistics for operations.\"\"\"\n    operation: str\n    count: int = 0\n    total_time: float = 0.0\n    min_time: float = float('inf')\n    max_time: float = 0.0\n    errors: int = 0\n    last_execution: Optional[datetime] = None\n    \n    @property\n    def avg_time(self) -> float:\n        return self.total_time / self.count if self.count > 0 else 0.0\n    \n    @property\n    def success_rate(self) -> float:\n        return (self.count - self.errors) / self.count if self.count > 0 else 1.0\n\n\nclass MetricsCollector:\n    \"\"\"Collects and manages system metrics.\"\"\"\n    \n    def __init__(self, retention_hours: int = 24):\n        self.retention_hours = retention_hours\n        self.metrics: Dict[str, deque] = defaultdict(lambda: deque())\n        self.performance_stats: Dict[str, PerformanceStats] = {}\n        self._lock = threading.Lock()\n        \n        # Prometheus metrics if available\n        if HAS_PROMETHEUS:\n            self.registry = CollectorRegistry()\n            self._setup_prometheus_metrics()\n        else:\n            self.registry = None\n    \n    def _setup_prometheus_metrics(self):\n        \"\"\"Setup Prometheus metrics.\"\"\"\n        if not HAS_PROMETHEUS:\n            return\n        \n        # System metrics\n        self.cpu_usage = Gauge('acousto_gen_cpu_usage_percent', 'CPU usage percentage', registry=self.registry)\n        self.memory_usage = Gauge('acousto_gen_memory_usage_bytes', 'Memory usage in bytes', registry=self.registry)\n        self.disk_usage = Gauge('acousto_gen_disk_usage_percent', 'Disk usage percentage', registry=self.registry)\n        \n        # Application metrics\n        self.active_experiments = Gauge('acousto_gen_active_experiments', 'Number of active experiments', registry=self.registry)\n        self.hardware_connections = Gauge('acousto_gen_hardware_connections', 'Number of connected hardware interfaces', registry=self.registry)\n        self.field_calculations = Counter('acousto_gen_field_calculations_total', 'Total field calculations performed', registry=self.registry)\n        \n        # Performance metrics\n        self.operation_duration = Histogram(\n            'acousto_gen_operation_duration_seconds',\n            'Duration of operations in seconds',\n            ['operation'],\n            registry=self.registry\n        )\n        \n        self.operation_errors = Counter(\n            'acousto_gen_operation_errors_total',\n            'Total operation errors',\n            ['operation', 'error_type'],\n            registry=self.registry\n        )\n        \n        # Safety metrics\n        self.safety_violations = Counter(\n            'acousto_gen_safety_violations_total',\n            'Total safety violations',\n            ['severity', 'type'],\n            registry=self.registry\n        )\n        \n        logger.info(\"Prometheus metrics initialized\")\n    \n    def record_metric(self, metric: SystemMetric):\n        \"\"\"Record a system metric.\"\"\"\n        with self._lock:\n            self.metrics[metric.name].append(metric)\n            \n            # Clean old metrics\n            cutoff_time = datetime.now() - timedelta(hours=self.retention_hours)\n            while (self.metrics[metric.name] and \n                   self.metrics[metric.name][0].timestamp < cutoff_time):\n                self.metrics[metric.name].popleft()\n    \n    def record_operation(self, operation: str, duration: float, success: bool = True, error_type: Optional[str] = None):\n        \"\"\"Record operation performance metrics.\"\"\"\n        with self._lock:\n            if operation not in self.performance_stats:\n                self.performance_stats[operation] = PerformanceStats(operation)\n            \n            stats = self.performance_stats[operation]\n            stats.count += 1\n            stats.total_time += duration\n            stats.min_time = min(stats.min_time, duration)\n            stats.max_time = max(stats.max_time, duration)\n            stats.last_execution = datetime.now()\n            \n            if not success:\n                stats.errors += 1\n        \n        # Update Prometheus metrics\n        if HAS_PROMETHEUS and self.registry:\n            self.operation_duration.labels(operation=operation).observe(duration)\n            if not success and error_type:\n                self.operation_errors.labels(operation=operation, error_type=error_type).inc()\n    \n    def get_metric_history(self, metric_name: str, hours: int = 1) -> List[SystemMetric]:\n        \"\"\"Get metric history for specified time period.\"\"\"\n        cutoff_time = datetime.now() - timedelta(hours=hours)\n        \n        with self._lock:\n            if metric_name in self.metrics:\n                return [m for m in self.metrics[metric_name] if m.timestamp > cutoff_time]\n            return []\n    \n    def get_metric_stats(self, metric_name: str, hours: int = 1) -> Optional[Dict[str, float]]:\n        \"\"\"Get statistical summary of a metric.\"\"\"\n        history = self.get_metric_history(metric_name, hours)\n        \n        if not history:\n            return None\n        \n        values = [m.value for m in history]\n        \n        return {\n            \"count\": len(values),\n            \"mean\": statistics.mean(values),\n            \"median\": statistics.median(values),\n            \"min\": min(values),\n            \"max\": max(values),\n            \"stdev\": statistics.stdev(values) if len(values) > 1 else 0.0\n        }\n    \n    def get_performance_stats(self, operation: str = None) -> Dict[str, Any]:\n        \"\"\"Get performance statistics.\"\"\"\n        with self._lock:\n            if operation:\n                if operation in self.performance_stats:\n                    return asdict(self.performance_stats[operation])\n                return {}\n            else:\n                return {op: asdict(stats) for op, stats in self.performance_stats.items()}\n    \n    def get_prometheus_metrics(self) -> Optional[str]:\n        \"\"\"Get Prometheus metrics in text format.\"\"\"\n        if HAS_PROMETHEUS and self.registry:\n            return generate_latest(self.registry).decode('utf-8')\n        return None\n\n\nclass SystemMonitor:\n    \"\"\"Comprehensive system monitoring for acoustic holography systems.\"\"\"\n    \n    def __init__(self, collection_interval: float = 10.0):\n        self.collection_interval = collection_interval\n        self.metrics_collector = MetricsCollector()\n        \n        # Monitoring state\n        self.monitoring_active = False\n        self.monitor_thread: Optional[threading.Thread] = None\n        self.stop_monitoring = False\n        \n        # Component monitors\n        self.hardware_monitors: Dict[str, Any] = {}\n        self.experiment_monitors: Dict[str, Any] = {}\n        \n        # Alert thresholds\n        self.alert_thresholds = {\n            \"cpu_usage\": 90.0,          # %\n            \"memory_usage\": 90.0,       # %\n            \"disk_usage\": 90.0,         # %\n            \"temperature\": 80.0,        # Â°C\n            \"error_rate\": 0.1,          # 10% error rate\n        }\n        \n        # Alert callbacks\n        self.alert_callbacks: List[Callable[[str, str, float], None]] = []\n        \n        logger.info(\"System Monitor initialized\")\n    \n    def add_hardware_monitor(self, hardware_id: str, hardware_interface: Any):\n        \"\"\"Add hardware interface to monitoring.\"\"\"\n        self.hardware_monitors[hardware_id] = hardware_interface\n        logger.info(f\"Added hardware monitor: {hardware_id}\")\n    \n    def add_experiment_monitor(self, experiment_id: str, experiment: Any):\n        \"\"\"Add experiment to monitoring.\"\"\"\n        self.experiment_monitors[experiment_id] = experiment\n        logger.info(f\"Added experiment monitor: {experiment_id}\")\n    \n    def add_alert_callback(self, callback: Callable[[str, str, float], None]):\n        \"\"\"Add callback for alert notifications.\"\"\"\n        self.alert_callbacks.append(callback)\n    \n    def start_monitoring(self):\n        \"\"\"Start system monitoring.\"\"\"\n        if self.monitoring_active:\n            logger.warning(\"System monitoring already active\")\n            return\n        \n        self.monitoring_active = True\n        self.stop_monitoring = False\n        \n        def monitor_loop():\n            while not self.stop_monitoring and self.monitoring_active:\n                try:\n                    self._collect_system_metrics()\n                    self._collect_hardware_metrics()\n                    self._collect_experiment_metrics()\n                    self._check_alerts()\n                    \n                    time.sleep(self.collection_interval)\n                except Exception as e:\n                    logger.error(f\"Error in system monitoring: {e}\")\n                    time.sleep(self.collection_interval)\n        \n        self.monitor_thread = threading.Thread(target=monitor_loop, daemon=True)\n        self.monitor_thread.start()\n        \n        logger.info(f\"System monitoring started with {self.collection_interval}s interval\")\n    \n    def stop_monitoring(self):\n        \"\"\"Stop system monitoring.\"\"\"\n        self.stop_monitoring = True\n        self.monitoring_active = False\n        \n        if self.monitor_thread:\n            self.monitor_thread.join(timeout=2.0)\n            self.monitor_thread = None\n        \n        logger.info(\"System monitoring stopped\")\n    \n    def _collect_system_metrics(self):\n        \"\"\"Collect system-level metrics.\"\"\"\n        try:\n            # CPU usage\n            cpu_percent = psutil.cpu_percent(interval=None)\n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"cpu_usage\",\n                value=cpu_percent,\n                unit=\"percent\",\n                help=\"CPU usage percentage\"\n            ))\n            \n            if HAS_PROMETHEUS and self.metrics_collector.registry:\n                self.metrics_collector.cpu_usage.set(cpu_percent)\n            \n            # Memory usage\n            memory = psutil.virtual_memory()\n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"memory_usage\",\n                value=memory.percent,\n                unit=\"percent\",\n                help=\"Memory usage percentage\"\n            ))\n            \n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"memory_used_bytes\",\n                value=memory.used,\n                unit=\"bytes\",\n                help=\"Memory used in bytes\"\n            ))\n            \n            if HAS_PROMETHEUS and self.metrics_collector.registry:\n                self.metrics_collector.memory_usage.set(memory.used)\n            \n            # Disk usage\n            disk = psutil.disk_usage('/')\n            disk_percent = (disk.used / disk.total) * 100\n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"disk_usage\",\n                value=disk_percent,\n                unit=\"percent\",\n                help=\"Disk usage percentage\"\n            ))\n            \n            if HAS_PROMETHEUS and self.metrics_collector.registry:\n                self.metrics_collector.disk_usage.set(disk_percent)\n            \n            # Process info\n            process = psutil.Process()\n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"process_memory_rss\",\n                value=process.memory_info().rss,\n                unit=\"bytes\",\n                help=\"Process resident memory\"\n            ))\n            \n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"process_cpu_percent\",\n                value=process.cpu_percent(),\n                unit=\"percent\",\n                help=\"Process CPU usage\"\n            ))\n            \n            # Thread count\n            self.metrics_collector.record_metric(SystemMetric(\n                name=\"thread_count\",\n                value=threading.active_count(),\n                unit=\"count\",\n                help=\"Active thread count\"\n            ))\n            \n        except Exception as e:\n            logger.error(f\"Error collecting system metrics: {e}\")\n    \n    def _collect_hardware_metrics(self):\n        \"\"\"Collect hardware-specific metrics.\"\"\"\n        connected_hardware = 0\n        \n        for hardware_id, interface in self.hardware_monitors.items():\n            try:\n                status = interface.get_status()\n                \n                if status.connected:\n                    connected_hardware += 1\n                \n                # Temperature\n                if hasattr(status, 'temperature') and status.temperature is not None:\n                    self.metrics_collector.record_metric(SystemMetric(\n                        name=\"hardware_temperature\",\n                        value=status.temperature,\n                        unit=\"celsius\",\n                        tags={\"hardware_id\": hardware_id},\n                        help=\"Hardware temperature\"\n                    ))\n                \n                # Voltage\n                if hasattr(status, 'voltage') and status.voltage is not None:\n                    self.metrics_collector.record_metric(SystemMetric(\n                        name=\"hardware_voltage\",\n                        value=status.voltage,\n                        unit=\"volts\",\n                        tags={\"hardware_id\": hardware_id},\n                        help=\"Hardware voltage\"\n                    ))\n                \n                # Current\n                if hasattr(status, 'current') and status.current is not None:\n                    self.metrics_collector.record_metric(SystemMetric(\n                        name=\"hardware_current\",\n                        value=status.current,\n                        unit=\"amperes\",\n                        tags={\"hardware_id\": hardware_id},\n                        help=\"Hardware current\"\n                    ))\n                \n                # Connection status\n                self.metrics_collector.record_metric(SystemMetric(\n                    name=\"hardware_connected\",\n                    value=1.0 if status.connected else 0.0,\n                    unit=\"boolean\",\n                    tags={\"hardware_id\": hardware_id},\n                    help=\"Hardware connection status\"\n                ))\n                \n            except Exception as e:\n                logger.error(f\"Error collecting metrics for hardware {hardware_id}: {e}\")\n        \n        # Update Prometheus hardware connections\n        if HAS_PROMETHEUS and self.metrics_collector.registry:\n            self.metrics_collector.hardware_connections.set(connected_hardware)\n    \n    def _collect_experiment_metrics(self):\n        \"\"\"Collect experiment-specific metrics.\"\"\"\n        active_experiments = len(self.experiment_monitors)\n        \n        self.metrics_collector.record_metric(SystemMetric(\n            name=\"active_experiments\",\n            value=active_experiments,\n            unit=\"count\",\n            help=\"Number of active experiments\"\n        ))\n        \n        if HAS_PROMETHEUS and self.metrics_collector.registry:\n            self.metrics_collector.active_experiments.set(active_experiments)\n        \n        # Collect per-experiment metrics\n        for experiment_id, experiment in self.experiment_monitors.items():\n            try:\n                if hasattr(experiment, 'get_metrics'):\n                    exp_metrics = experiment.get_metrics()\n                    \n                    for metric_name, value in exp_metrics.items():\n                        self.metrics_collector.record_metric(SystemMetric(\n                            name=f\"experiment_{metric_name}\",\n                            value=value,\n                            unit=\"unknown\",\n                            tags={\"experiment_id\": experiment_id},\n                            help=f\"Experiment metric: {metric_name}\"\n                        ))\n                        \n            except Exception as e:\n                logger.error(f\"Error collecting metrics for experiment {experiment_id}: {e}\")\n    \n    def _check_alerts(self):\n        \"\"\"Check for alert conditions.\"\"\"\n        # Check CPU usage\n        cpu_stats = self.metrics_collector.get_metric_stats(\"cpu_usage\", hours=0.1)  # 6 minutes\n        if cpu_stats and cpu_stats[\"mean\"] > self.alert_thresholds[\"cpu_usage\"]:\n            self._trigger_alert(\"cpu_usage\", \"High CPU usage\", cpu_stats[\"mean\"])\n        \n        # Check memory usage\n        memory_stats = self.metrics_collector.get_metric_stats(\"memory_usage\", hours=0.1)\n        if memory_stats and memory_stats[\"mean\"] > self.alert_thresholds[\"memory_usage\"]:\n            self._trigger_alert(\"memory_usage\", \"High memory usage\", memory_stats[\"mean\"])\n        \n        # Check disk usage\n        disk_stats = self.metrics_collector.get_metric_stats(\"disk_usage\", hours=0.1)\n        if disk_stats and disk_stats[\"mean\"] > self.alert_thresholds[\"disk_usage\"]:\n            self._trigger_alert(\"disk_usage\", \"High disk usage\", disk_stats[\"mean\"])\n        \n        # Check hardware temperatures\n        temp_metrics = self.metrics_collector.get_metric_history(\"hardware_temperature\", hours=0.1)\n        for metric in temp_metrics:\n            if metric.value > self.alert_thresholds[\"temperature\"]:\n                hardware_id = metric.tags.get(\"hardware_id\", \"unknown\")\n                self._trigger_alert(\"temperature\", f\"High temperature on {hardware_id}\", metric.value)\n        \n        # Check operation error rates\n        for operation, stats in self.metrics_collector.performance_stats.items():\n            if stats.count > 10:  # Only check if we have enough samples\n                error_rate = stats.errors / stats.count\n                if error_rate > self.alert_thresholds[\"error_rate\"]:\n                    self._trigger_alert(\"error_rate\", f\"High error rate for {operation}\", error_rate)\n    \n    def _trigger_alert(self, alert_type: str, message: str, value: float):\n        \"\"\"Trigger an alert notification.\"\"\"\n        logger.warning(f\"ALERT [{alert_type}]: {message} (value: {value})\")\n        \n        for callback in self.alert_callbacks:\n            try:\n                callback(alert_type, message, value)\n            except Exception as e:\n                logger.error(f\"Error in alert callback: {e}\")\n    \n    def get_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system status.\"\"\"\n        status = {\n            \"monitoring_active\": self.monitoring_active,\n            \"collection_interval\": self.collection_interval,\n            \"hardware_monitors\": len(self.hardware_monitors),\n            \"experiment_monitors\": len(self.experiment_monitors),\n            \"metrics\": {}\n        }\n        \n        # Add recent metrics\n        key_metrics = [\"cpu_usage\", \"memory_usage\", \"disk_usage\", \"active_experiments\"]\n        for metric_name in key_metrics:\n            stats = self.metrics_collector.get_metric_stats(metric_name, hours=0.1)\n            if stats:\n                status[\"metrics\"][metric_name] = {\n                    \"current\": stats[\"mean\"],\n                    \"min\": stats[\"min\"],\n                    \"max\": stats[\"max\"]\n                }\n        \n        # Add performance stats\n        status[\"performance\"] = self.metrics_collector.get_performance_stats()\n        \n        return status\n    \n    def get_health_check(self) -> Dict[str, Any]:\n        \"\"\"Get system health check.\"\"\"\n        health = {\n            \"status\": \"healthy\",\n            \"timestamp\": datetime.now().isoformat(),\n            \"checks\": {}\n        }\n        \n        try:\n            # Check system resources\n            cpu_percent = psutil.cpu_percent(interval=1)\n            memory_percent = psutil.virtual_memory().percent\n            disk_percent = (lambda d: d.used / d.total * 100)(psutil.disk_usage('/'))\n            \n            health[\"checks\"][\"cpu\"] = {\n                \"status\": \"ok\" if cpu_percent < 90 else \"warning\",\n                \"value\": cpu_percent,\n                \"unit\": \"%\"\n            }\n            \n            health[\"checks\"][\"memory\"] = {\n                \"status\": \"ok\" if memory_percent < 90 else \"warning\",\n                \"value\": memory_percent,\n                \"unit\": \"%\"\n            }\n            \n            health[\"checks\"][\"disk\"] = {\n                \"status\": \"ok\" if disk_percent < 90 else \"warning\",\n                \"value\": disk_percent,\n                \"unit\": \"%\"\n            }\n            \n            # Check hardware connections\n            connected_hardware = sum(1 for hw in self.hardware_monitors.values() \n                                   if hw.get_status().connected)\n            total_hardware = len(self.hardware_monitors)\n            \n            health[\"checks\"][\"hardware\"] = {\n                \"status\": \"ok\" if connected_hardware == total_hardware else \"warning\",\n                \"connected\": connected_hardware,\n                \"total\": total_hardware\n            }\n            \n            # Overall status\n            warning_checks = [check for check in health[\"checks\"].values() \n                            if check[\"status\"] != \"ok\"]\n            if warning_checks:\n                health[\"status\"] = \"warning\"\n            \n        except Exception as e:\n            health[\"status\"] = \"error\"\n            health[\"error\"] = str(e)\n            logger.error(f\"Health check error: {e}\")\n        \n        return health\n\n\n# Global monitor instance\n_system_monitor: Optional[SystemMonitor] = None\n\n\ndef get_system_monitor() -> SystemMonitor:\n    \"\"\"Get global system monitor instance.\"\"\"\n    global _system_monitor\n    if _system_monitor is None:\n        _system_monitor = SystemMonitor()\n    return _system_monitor\n\n\ndef initialize_monitoring(collection_interval: float = 10.0, start_monitoring: bool = True):\n    \"\"\"Initialize global system monitoring.\"\"\"\n    global _system_monitor\n    _system_monitor = SystemMonitor(collection_interval)\n    \n    if start_monitoring:\n        _system_monitor.start_monitoring()\n    \n    logger.info(\"Global system monitoring initialized\")\n"